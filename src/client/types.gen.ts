// This file is auto-generated by @hey-api/openapi-ts

export type Files = {
    /**
     * Unique identifier for the file.
     */
    id?: string;
    /**
     * Where the file is stored. Either `local` for the local filesystem or the name of the storage adapter (for example `s3`).
     */
    storage?: string;
    /**
     * Name of the file on disk. By default, Directus uses a random hash for the filename.
     */
    filename_disk?: string;
    /**
     * How you want to the file to be named when it's being downloaded.
     */
    filename_download?: string;
    /**
     * Title for the file. Is extracted from the filename on upload, but can be edited by the user.
     */
    title?: string;
    /**
     * MIME type of the file.
     */
    type?: string;
    /**
     * Virtual folder where this file resides in.
     */
    folder?: string | Folders | null;
    /**
     * Who uploaded the file.
     */
    uploaded_by?: string | Users;
    /**
     * When the file was created.
     */
    created_on?: Date;
    modified_by?: string | Users | null;
    modified_on?: string;
    /**
     * Character set of the file.
     */
    charset?: string | null;
    /**
     * Size of the file in bytes.
     */
    filesize?: number;
    /**
     * Width of the file in pixels. Only applies to images.
     */
    width?: number | null;
    /**
     * Height of the file in pixels. Only applies to images.
     */
    height?: number | null;
    /**
     * Duration of the file in seconds. Only applies to audio and video.
     */
    duration?: number | null;
    /**
     * Where the file was embedded from.
     */
    embed?: string | null;
    /**
     * Description for the file.
     */
    description?: string | null;
    /**
     * Where the file was created. Is automatically populated based on Exif data for images.
     */
    location?: string | null;
    /**
     * Tags for the file. Is automatically populated based on Exif data for images.
     */
    tags?: Array<string> | null;
    /**
     * IPTC, Exif, and ICC metadata extracted from file
     */
    metadata?: {
        [key: string]: unknown;
    } | null;
    focal_point_x?: number | null;
    focal_point_y?: number | null;
    tus_id?: string | null;
    tus_data?: unknown;
    /**
     * When the file was last uploaded/replaced.
     */
    uploaded_on?: Date;
};

export type Folders = {
    /**
     * Unique identifier for the folder.
     */
    id?: string;
    /**
     * Name of the folder.
     */
    name?: string;
    /**
     * Unique identifier of the parent folder. This allows for nested folders.
     */
    parent?: string | Folders | null;
};

export type Roles = {
    /**
     * Unique identifier for the role.
     */
    id?: string;
    /**
     * Name of the role.
     */
    name?: string;
    /**
     * The role's icon.
     */
    icon?: string;
    /**
     * Description of the role.
     */
    description?: string | null;
    /**
     * Array of IP addresses that are allowed to connect to the API as a user of this role.
     */
    ip_access?: Array<string>;
    /**
     * Whether or not this role enforces the use of 2FA.
     */
    enforce_tfa?: boolean;
    /**
     * Admin role. If true, skips all permission checks.
     */
    admin_access?: boolean;
    /**
     * The users in the role are allowed to use the app.
     */
    app_access?: boolean;
};

export type Users = {
    /**
     * Unique identifier for the user.
     */
    id?: string;
    /**
     * Unique identifier of the role of this user.
     */
    role?: string | Roles;
};

export type Query = {
    /**
     * Control what fields are being returned in the object.
     */
    fields?: Array<string>;
    filter?: {
        [key: string]: unknown;
    };
    /**
     * Filter by items that contain the given search query in one of their fields.
     */
    search?: string;
    /**
     * How to sort the returned items.
     */
    sort?: Array<string>;
    /**
     * Set the maximum number of items that will be returned
     */
    limit?: number;
    /**
     * How many items to skip when fetching data.
     */
    offset?: number;
    /**
     * Cursor for use in pagination. Often used in combination with limit.
     */
    page?: number;
    /**
     * Deep allows you to set any of the other query parameters on a nested relational dataset.
     */
    deep?: {
        [key: string]: unknown;
    };
};

export type XMetadata = {
    /**
     * Returns the total item count of the collection you're querying.
     */
    total_count?: number;
    /**
     * Returns the item count of the collection you're querying, taking the current filter/search parameters into account.
     */
    filter_count?: number;
};

export type Fields = {
    id?: number;
    /**
     * Unique name of the collection this field is in.
     */
    collection?: string;
    /**
     * Unique name of the field. Field name is unique within the collection.
     */
    field?: string;
    special?: Array<string> | null;
    interface?: string | null;
    options?: unknown;
    display?: string | null;
    display_options?: unknown;
    readonly?: boolean;
    hidden?: boolean;
    sort?: number | null;
    width?: string | null;
    translations?: unknown;
    note?: string | null;
    conditions?: unknown;
    required?: boolean | null;
    group?: number | Fields | null;
    validation?: unknown;
    validation_message?: string | null;
};

export type ItemsBewertungKleinerKreis = {
    id?: number;
    bezeichner?: string | null;
    rangfolge?: number | null;
};

export type ItemsObjekt = {
    id?: number;
    status?: string;
    user_created?: string | Users | null;
    date_created?: string | null;
    user_updated?: string | Users | null;
    date_updated?: string | null;
    name?: string | null;
    datierung?: string | null;
    /**
     * Foto / Abbildung, auf dem das Objekt gezeigt wird
     */
    abbildung?: string | Files | null;
    beschreibung?: string | null;
    art?: string | null;
    format?: string | null;
    einreicherName?: string | null;
    einreicherGemeinde?: string | null;
    kontaktRueckfrage?: string | null;
    objektAusleihenFuerAusstellung?: boolean | null;
    bewertung?: number | ItemsBewertungKleinerKreis | null;
    /**
     * Kategorie/Überschrift zur Gruppierung von Objekten
     */
    kategorie?: unknown;
    aktuellerStandort?: string | null;
    anmerkung?: string | null;
    type?: string | null;
    /**
     * Weitere Abbildungen oder ergänzende Dateien
     */
    weitereAbbildungen?: Array<number | ItemsObjektFiles> | null;
};

export type ItemsObjektFiles = {
    id?: number;
    objekt_id?: number | ItemsObjekt | null;
    directus_files_id?: string | Files | null;
};

/**
 * Index
 */
export type Id = number;

/**
 * Unique identifier for the object.
 */
export type UuId = string;

/**
 * Collection of which you want to retrieve the items from.
 */
export type Collection = string;

/**
 * Filter by items that contain the given search query in one of their fields.
 */
export type Search = string;

/**
 * Cursor for use in pagination. Often used in combination with limit.
 */
export type Page = number;

/**
 * How many items to skip when fetching data.
 */
export type Offset = number;

/**
 * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
 *
 */
export type Sort = Array<string>;

/**
 * What metadata to return in the response.
 */
export type Meta = string;

/**
 * A limit on the number of objects that are returned.
 */
export type Limit = number;

/**
 * Select items in collection by given conditions.
 */
export type Filter = {
    [key: string]: unknown;
};

/**
 * Control what fields are being returned in the object.
 */
export type Fields2 = Array<string>;

/**
 * Saves the API response to a file. Accepts one of "csv", "json", "xml", "yaml".
 */
export type Export = 'csv' | 'json' | 'xml' | 'yaml';

/**
 * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
 *
 */
export type Version = string;

export type GetAssetData = {
    body?: never;
    path: {
        /**
         * The id of the file.
         */
        id: string;
    };
    query?: {
        /**
         * The key of the asset size configured in settings.
         */
        key?: string;
        /**
         * A JSON array of image transformations
         */
        transforms?: string;
        /**
         * Download the asset to your computer
         */
        download?: boolean;
    };
    url: '/assets/{id}';
};

export type GetAssetErrors = {
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type GetAssetError = GetAssetErrors[keyof GetAssetErrors];

export type GetAssetResponses = {
    /**
     * Successful request
     */
    200: string;
};

export type GetAssetResponse = GetAssetResponses[keyof GetAssetResponses];

export type LoginData = {
    body?: {
        /**
         * Email address of the user you're retrieving the access token for.
         */
        email: string;
        /**
         * Password of the user.
         */
        password: string;
        /**
         * Whether to retrieve the refresh token in the JSON response, or in a httpOnly cookie.
         */
        mode?: 'json' | 'cookie' | 'session';
        /**
         * The user's one-time-password (if MFA is enabled).
         */
        otp?: string;
    };
    path?: never;
    query?: never;
    url: '/auth/login';
};

export type LoginResponses = {
    /**
     * Successful authentification
     */
    200: {
        data?: {
            access_token?: string;
            expires?: number;
            refresh_token?: string;
        };
    };
};

export type LoginResponse = LoginResponses[keyof LoginResponses];

export type RefreshData = {
    body?: {
        /**
         * JWT access token you want to refresh. This token can't be expired.
         */
        refresh_token?: string;
        /**
         * Whether to submit and retrieve the refresh token in the JSON response, or in a httpOnly cookie.
         */
        mode?: 'json' | 'cookie' | 'session';
    };
    path?: never;
    query?: never;
    url: '/auth/refresh';
};

export type RefreshErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type RefreshError = RefreshErrors[keyof RefreshErrors];

export type RefreshResponses = {
    /**
     * Successful request
     */
    200: {
        data?: {
            access_token?: string;
            expires?: number;
            refresh_token?: string;
        };
    };
};

export type RefreshResponse = RefreshResponses[keyof RefreshResponses];

export type LogoutData = {
    body?: {
        /**
         * The refresh token to invalidate. If you have the refresh token in a cookie through /auth/login, you don't have to submit it here.
         */
        refresh_token?: string;
        /**
         * Whether the refresh token is submitted in the JSON response, or in a httpOnly cookie.
         */
        mode?: 'json' | 'cookie' | 'session';
    };
    path?: never;
    query?: never;
    url: '/auth/logout';
};

export type LogoutResponses = {
    /**
     * Request successful
     */
    200: unknown;
};

export type PasswordRequestData = {
    body?: {
        /**
         * Email address of the user you're requesting a reset for.
         */
        email: string;
    };
    path?: never;
    query?: never;
    url: '/auth/password/request';
};

export type PasswordRequestErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type PasswordRequestError = PasswordRequestErrors[keyof PasswordRequestErrors];

export type PasswordResetData = {
    body?: {
        /**
         * One-time use JWT token that is used to verify the user.
         */
        token: string;
        /**
         * New password for the user.
         */
        password: string;
    };
    path?: never;
    query?: never;
    url: '/auth/password/reset';
};

export type PasswordResetErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type PasswordResetError = PasswordResetErrors[keyof PasswordResetErrors];

export type OauthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/oauth';
};

export type OauthErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type OauthError = OauthErrors[keyof OauthErrors];

export type OauthResponses = {
    /**
     * Successful request
     */
    200: {
        public?: boolean;
        data?: Array<string>;
    };
};

export type OauthResponse = OauthResponses[keyof OauthResponses];

export type OauthProviderData = {
    body?: never;
    path: {
        /**
         * Key of the activated OAuth provider.
         */
        provider: string;
    };
    query?: {
        /**
         * Where to redirect on successful login.<br/>If set the authentication details are set inside cookies otherwise a JSON is returned.
         */
        redirect?: string;
    };
    url: '/auth/oauth/{provider}';
};

export type OauthProviderErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type OauthProviderError = OauthProviderErrors[keyof OauthProviderErrors];

export type OauthProviderResponses = {
    /**
     * Successful request
     */
    200: {
        public?: boolean;
        data?: {
            token?: string;
        };
    };
};

export type OauthProviderResponse = OauthProviderResponses[keyof OauthProviderResponses];

export type ServerInfoData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in `/config/__api.json` on your server.
         */
        super_admin_token: number;
    };
    url: '/server/info';
};

export type ServerInfoErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type ServerInfoError = ServerInfoErrors[keyof ServerInfoErrors];

export type ServerInfoResponses = {
    /**
     * Successful request
     */
    200: {
        data?: {
            [key: string]: unknown;
        };
    };
};

export type ServerInfoResponse = ServerInfoResponses[keyof ServerInfoResponses];

export type PingData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/server/ping';
};

export type PingResponses = {
    /**
     * Successful request
     */
    200: string;
};

export type PingResponse = PingResponses[keyof PingResponses];

export type HashGenerateData = {
    body?: {
        /**
         * String to hash.
         */
        string: string;
    };
    path?: never;
    query?: never;
    url: '/utils/hash/generate';
};

export type HashGenerateResponses = {
    /**
     * Successful request
     */
    200: {
        data?: string;
    };
};

export type HashGenerateResponse = HashGenerateResponses[keyof HashGenerateResponses];

export type HashVerifyData = {
    body?: {
        /**
         * String to hash.
         */
        string: string;
        /**
         * Hash you want to verify against.
         */
        hash: string;
    };
    path?: never;
    query?: never;
    url: '/utils/hash/verify';
};

export type HashVerifyResponses = {
    /**
     * Successful request
     */
    200: {
        data?: boolean;
    };
};

export type HashVerifyResponse = HashVerifyResponses[keyof HashVerifyResponses];

export type SortData = {
    body?: {
        /**
         * Primary key of item to move
         */
        item?: number;
        /**
         * Primary key of item where to move the current item to
         */
        to?: number;
    };
    path: {
        /**
         * Collection identifier
         */
        collection: string;
    };
    query?: never;
    url: '/utils/sort/{collection}';
};

export type SortResponses = {
    /**
     * Successful request
     */
    200: unknown;
};

export type ImportData = {
    body?: {
        file?: Blob | File;
    };
    path: {
        /**
         * Collection identifier
         */
        collection: string;
    };
    query?: never;
    url: '/utils/import/{collection}';
};

export type ImportResponses = {
    /**
     * Successful request
     */
    200: unknown;
};

export type ExportData = {
    body?: {
        /**
         * What file format to save the export to. One of csv, xml, json
         */
        format: 'csv' | 'xml' | 'json';
        query: Query;
        file: Files;
    };
    path: {
        /**
         * Collection identifier
         */
        collection: string;
    };
    query?: never;
    url: '/utils/export/{collection}';
};

export type ExportResponses = {
    /**
     * Successful request
     */
    200: unknown;
};

export type ClearCacheData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/utils/cache/clear';
};

export type ClearCacheResponses = {
    /**
     * Successful request
     */
    200: unknown;
};

export type RandomData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Length of the random string.
         */
        length?: number;
    };
    url: '/utils/random/string';
};

export type RandomResponses = {
    /**
     * Successful request
     */
    200: {
        data?: string;
    };
};

export type RandomResponse = RandomResponses[keyof RandomResponses];

export type GetFilesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * A limit on the number of objects that are returned.
         */
        limit?: number;
        /**
         * How many items to skip when fetching data.
         */
        offset?: number;
        /**
         * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *
         */
        sort?: Array<string>;
        /**
         * Select items in collection by given conditions.
         */
        filter?: {
            [key: string]: unknown;
        };
        /**
         * Filter by items that contain the given search query in one of their fields.
         */
        search?: string;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
    };
    url: '/files';
};

export type GetFilesErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type GetFilesError = GetFilesErrors[keyof GetFilesErrors];

export type GetFilesResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Array<Files>;
        meta?: XMetadata;
    };
};

export type GetFilesResponse = GetFilesResponses[keyof GetFilesResponses];

export type CreateFileData = {
    body?: {
        data?: string;
    };
    path?: never;
    query?: never;
    url: '/files';
};

export type CreateFileErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type CreateFileError = CreateFileErrors[keyof CreateFileErrors];

export type CreateFileResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Files;
    };
};

export type CreateFileResponse = CreateFileResponses[keyof CreateFileResponses];

export type GetFileData = {
    body?: never;
    path: {
        /**
         * Unique identifier for the object.
         */
        id: string;
    };
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
    };
    url: '/files/{id}';
};

export type GetFileErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type GetFileError = GetFileErrors[keyof GetFileErrors];

export type GetFileResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Files;
    };
};

export type GetFileResponse = GetFileResponses[keyof GetFileResponses];

export type GetFieldsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * A limit on the number of objects that are returned.
         */
        limit?: number;
        /**
         * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *
         */
        sort?: Array<string>;
    };
    url: '/fields';
};

export type GetFieldsErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type GetFieldsError = GetFieldsErrors[keyof GetFieldsErrors];

export type GetFieldsResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Array<Fields>;
    };
};

export type GetFieldsResponse = GetFieldsResponses[keyof GetFieldsResponses];

export type GetCollectionFieldsData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the collection the item resides in.
         */
        collection: string;
    };
    query?: {
        /**
         * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *
         */
        sort?: Array<string>;
    };
    url: '/fields/{collection}';
};

export type GetCollectionFieldsErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type GetCollectionFieldsError = GetCollectionFieldsErrors[keyof GetCollectionFieldsErrors];

export type GetCollectionFieldsResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Array<Fields>;
    };
};

export type GetCollectionFieldsResponse = GetCollectionFieldsResponses[keyof GetCollectionFieldsResponses];

export type GetCollectionFieldData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the collection the item resides in.
         */
        collection: string;
        /**
         * Unique identifier of the field.
         */
        id: string;
    };
    query?: never;
    url: '/fields/{collection}/{id}';
};

export type GetCollectionFieldErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type GetCollectionFieldError = GetCollectionFieldErrors[keyof GetCollectionFieldErrors];

export type GetCollectionFieldResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Fields;
    };
};

export type GetCollectionFieldResponse = GetCollectionFieldResponses[keyof GetCollectionFieldResponses];

export type GetUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * A limit on the number of objects that are returned.
         */
        limit?: number;
        /**
         * How many items to skip when fetching data.
         */
        offset?: number;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
        /**
         * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *
         */
        sort?: Array<string>;
        /**
         * Select items in collection by given conditions.
         */
        filter?: {
            [key: string]: unknown;
        };
        /**
         * Filter by items that contain the given search query in one of their fields.
         */
        search?: string;
    };
    url: '/users';
};

export type GetUsersErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type GetUsersError = GetUsersErrors[keyof GetUsersErrors];

export type GetUsersResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Array<Users>;
        meta?: XMetadata;
    };
};

export type GetUsersResponse = GetUsersResponses[keyof GetUsersResponses];

export type GetUserData = {
    body?: never;
    path: {
        /**
         * Unique identifier for the object.
         */
        id: string;
    };
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
    };
    url: '/users/{id}';
};

export type GetUserErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type GetUserError = GetUserErrors[keyof GetUserErrors];

export type GetUserResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Users;
    };
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type GetMeData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
    };
    url: '/users/me';
};

export type GetMeErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type GetMeError = GetMeErrors[keyof GetMeErrors];

export type GetMeResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Users;
    };
};

export type GetMeResponse = GetMeResponses[keyof GetMeResponses];

export type ReadItemsBewertungKleinerKreisData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * A limit on the number of objects that are returned.
         */
        limit?: number;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
        /**
         * How many items to skip when fetching data.
         */
        offset?: number;
        /**
         * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *
         */
        sort?: Array<string>;
        /**
         * Select items in collection by given conditions.
         */
        filter?: {
            [key: string]: unknown;
        };
        /**
         * Filter by items that contain the given search query in one of their fields.
         */
        search?: string;
    };
    url: '/items/bewertungKleinerKreis';
};

export type ReadItemsBewertungKleinerKreisErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type ReadItemsBewertungKleinerKreisError = ReadItemsBewertungKleinerKreisErrors[keyof ReadItemsBewertungKleinerKreisErrors];

export type ReadItemsBewertungKleinerKreisResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Array<ItemsBewertungKleinerKreis>;
        meta?: XMetadata;
    };
};

export type ReadItemsBewertungKleinerKreisResponse = ReadItemsBewertungKleinerKreisResponses[keyof ReadItemsBewertungKleinerKreisResponses];

export type ReadSingleItemsBewertungKleinerKreisData = {
    body?: never;
    path: {
        /**
         * Index of the item.
         */
        id: number | string;
    };
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
        /**
         * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
         *
         */
        version?: string;
    };
    url: '/items/bewertungKleinerKreis/{id}';
};

export type ReadSingleItemsBewertungKleinerKreisErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type ReadSingleItemsBewertungKleinerKreisError = ReadSingleItemsBewertungKleinerKreisErrors[keyof ReadSingleItemsBewertungKleinerKreisErrors];

export type ReadSingleItemsBewertungKleinerKreisResponses = {
    /**
     * Successful request
     */
    200: {
        data?: ItemsBewertungKleinerKreis;
    };
};

export type ReadSingleItemsBewertungKleinerKreisResponse = ReadSingleItemsBewertungKleinerKreisResponses[keyof ReadSingleItemsBewertungKleinerKreisResponses];

export type DeleteItemsObjektData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/items/objekt';
};

export type DeleteItemsObjektErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type DeleteItemsObjektError = DeleteItemsObjektErrors[keyof DeleteItemsObjektErrors];

export type DeleteItemsObjektResponses = {
    /**
     * Successful request
     */
    200: unknown;
};

export type ReadItemsObjektData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * A limit on the number of objects that are returned.
         */
        limit?: number;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
        /**
         * How many items to skip when fetching data.
         */
        offset?: number;
        /**
         * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *
         */
        sort?: Array<string>;
        /**
         * Select items in collection by given conditions.
         */
        filter?: {
            [key: string]: unknown;
        };
        /**
         * Filter by items that contain the given search query in one of their fields.
         */
        search?: string;
    };
    url: '/items/objekt';
};

export type ReadItemsObjektErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type ReadItemsObjektError = ReadItemsObjektErrors[keyof ReadItemsObjektErrors];

export type ReadItemsObjektResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Array<ItemsObjekt>;
        meta?: XMetadata;
    };
};

export type ReadItemsObjektResponse = ReadItemsObjektResponses[keyof ReadItemsObjektResponses];

export type UpdateItemsObjektData = {
    body?: Array<ItemsObjekt> | ItemsObjekt;
    path?: never;
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * A limit on the number of objects that are returned.
         */
        limit?: number;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
        /**
         * How many items to skip when fetching data.
         */
        offset?: number;
        /**
         * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *
         */
        sort?: Array<string>;
        /**
         * Select items in collection by given conditions.
         */
        filter?: {
            [key: string]: unknown;
        };
        /**
         * Filter by items that contain the given search query in one of their fields.
         */
        search?: string;
    };
    url: '/items/objekt';
};

export type UpdateItemsObjektResponses = {
    /**
     * Successful request
     */
    200: {
        data?: unknown;
    };
};

export type UpdateItemsObjektResponse = UpdateItemsObjektResponses[keyof UpdateItemsObjektResponses];

export type CreateItemsObjektData = {
    body?: Array<ItemsObjekt> | ItemsObjekt;
    path?: never;
    query?: {
        /**
         * What metadata to return in the response.
         */
        meta?: string;
    };
    url: '/items/objekt';
};

export type CreateItemsObjektErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type CreateItemsObjektError = CreateItemsObjektErrors[keyof CreateItemsObjektErrors];

export type CreateItemsObjektResponses = {
    /**
     * Successful request
     */
    200: {
        data?: unknown;
    };
};

export type CreateItemsObjektResponse = CreateItemsObjektResponses[keyof CreateItemsObjektResponses];

export type DeleteSingleItemsObjektData = {
    body?: never;
    path: {
        /**
         * Index of the item.
         */
        id: number | string;
    };
    query?: never;
    url: '/items/objekt/{id}';
};

export type DeleteSingleItemsObjektErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type DeleteSingleItemsObjektError = DeleteSingleItemsObjektErrors[keyof DeleteSingleItemsObjektErrors];

export type DeleteSingleItemsObjektResponses = {
    /**
     * Successful request
     */
    200: unknown;
};

export type ReadSingleItemsObjektData = {
    body?: never;
    path: {
        /**
         * Index of the item.
         */
        id: number | string;
    };
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
        /**
         * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
         *
         */
        version?: string;
    };
    url: '/items/objekt/{id}';
};

export type ReadSingleItemsObjektErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type ReadSingleItemsObjektError = ReadSingleItemsObjektErrors[keyof ReadSingleItemsObjektErrors];

export type ReadSingleItemsObjektResponses = {
    /**
     * Successful request
     */
    200: {
        data?: ItemsObjekt;
    };
};

export type ReadSingleItemsObjektResponse = ReadSingleItemsObjektResponses[keyof ReadSingleItemsObjektResponses];

export type UpdateSingleItemsObjektData = {
    body?: ItemsObjekt;
    path: {
        /**
         * Index of the item.
         */
        id: number | string;
    };
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
    };
    url: '/items/objekt/{id}';
};

export type UpdateSingleItemsObjektErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type UpdateSingleItemsObjektError = UpdateSingleItemsObjektErrors[keyof UpdateSingleItemsObjektErrors];

export type UpdateSingleItemsObjektResponses = {
    /**
     * Successful request
     */
    200: {
        data?: ItemsObjekt;
    };
};

export type UpdateSingleItemsObjektResponse = UpdateSingleItemsObjektResponses[keyof UpdateSingleItemsObjektResponses];

export type DeleteItemsObjektFilesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/items/objekt_files';
};

export type DeleteItemsObjektFilesErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type DeleteItemsObjektFilesError = DeleteItemsObjektFilesErrors[keyof DeleteItemsObjektFilesErrors];

export type DeleteItemsObjektFilesResponses = {
    /**
     * Successful request
     */
    200: unknown;
};

export type ReadItemsObjektFilesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * A limit on the number of objects that are returned.
         */
        limit?: number;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
        /**
         * How many items to skip when fetching data.
         */
        offset?: number;
        /**
         * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *
         */
        sort?: Array<string>;
        /**
         * Select items in collection by given conditions.
         */
        filter?: {
            [key: string]: unknown;
        };
        /**
         * Filter by items that contain the given search query in one of their fields.
         */
        search?: string;
    };
    url: '/items/objekt_files';
};

export type ReadItemsObjektFilesErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type ReadItemsObjektFilesError = ReadItemsObjektFilesErrors[keyof ReadItemsObjektFilesErrors];

export type ReadItemsObjektFilesResponses = {
    /**
     * Successful request
     */
    200: {
        data?: Array<ItemsObjektFiles>;
        meta?: XMetadata;
    };
};

export type ReadItemsObjektFilesResponse = ReadItemsObjektFilesResponses[keyof ReadItemsObjektFilesResponses];

export type UpdateItemsObjektFilesData = {
    body?: Array<ItemsObjektFiles> | ItemsObjektFiles;
    path?: never;
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * A limit on the number of objects that are returned.
         */
        limit?: number;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
        /**
         * How many items to skip when fetching data.
         */
        offset?: number;
        /**
         * How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly.
         *
         */
        sort?: Array<string>;
        /**
         * Select items in collection by given conditions.
         */
        filter?: {
            [key: string]: unknown;
        };
        /**
         * Filter by items that contain the given search query in one of their fields.
         */
        search?: string;
    };
    url: '/items/objekt_files';
};

export type UpdateItemsObjektFilesResponses = {
    /**
     * Successful request
     */
    200: {
        data?: unknown;
    };
};

export type UpdateItemsObjektFilesResponse = UpdateItemsObjektFilesResponses[keyof UpdateItemsObjektFilesResponses];

export type CreateItemsObjektFilesData = {
    body?: Array<ItemsObjektFiles> | ItemsObjektFiles;
    path?: never;
    query?: {
        /**
         * What metadata to return in the response.
         */
        meta?: string;
    };
    url: '/items/objekt_files';
};

export type CreateItemsObjektFilesErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type CreateItemsObjektFilesError = CreateItemsObjektFilesErrors[keyof CreateItemsObjektFilesErrors];

export type CreateItemsObjektFilesResponses = {
    /**
     * Successful request
     */
    200: {
        data?: unknown;
    };
};

export type CreateItemsObjektFilesResponse = CreateItemsObjektFilesResponses[keyof CreateItemsObjektFilesResponses];

export type DeleteSingleItemsObjektFilesData = {
    body?: never;
    path: {
        /**
         * Index of the item.
         */
        id: number | string;
    };
    query?: never;
    url: '/items/objekt_files/{id}';
};

export type DeleteSingleItemsObjektFilesErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type DeleteSingleItemsObjektFilesError = DeleteSingleItemsObjektFilesErrors[keyof DeleteSingleItemsObjektFilesErrors];

export type DeleteSingleItemsObjektFilesResponses = {
    /**
     * Successful request
     */
    200: unknown;
};

export type ReadSingleItemsObjektFilesData = {
    body?: never;
    path: {
        /**
         * Index of the item.
         */
        id: number | string;
    };
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
        /**
         * Retrieve an item's state from a specific Content Version. The value corresponds to the "key" of the Content Version.
         *
         */
        version?: string;
    };
    url: '/items/objekt_files/{id}';
};

export type ReadSingleItemsObjektFilesErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type ReadSingleItemsObjektFilesError = ReadSingleItemsObjektFilesErrors[keyof ReadSingleItemsObjektFilesErrors];

export type ReadSingleItemsObjektFilesResponses = {
    /**
     * Successful request
     */
    200: {
        data?: ItemsObjektFiles;
    };
};

export type ReadSingleItemsObjektFilesResponse = ReadSingleItemsObjektFilesResponses[keyof ReadSingleItemsObjektFilesResponses];

export type UpdateSingleItemsObjektFilesData = {
    body?: ItemsObjektFiles;
    path: {
        /**
         * Index of the item.
         */
        id: number | string;
    };
    query?: {
        /**
         * Control what fields are being returned in the object.
         */
        fields?: Array<string>;
        /**
         * What metadata to return in the response.
         */
        meta?: string;
    };
    url: '/items/objekt_files/{id}';
};

export type UpdateSingleItemsObjektFilesErrors = {
    /**
     * Error: Unauthorized request
     */
    401: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
    /**
     * Error: Not found.
     */
    404: {
        error?: {
            code?: bigint;
            message?: string;
        };
    };
};

export type UpdateSingleItemsObjektFilesError = UpdateSingleItemsObjektFilesErrors[keyof UpdateSingleItemsObjektFilesErrors];

export type UpdateSingleItemsObjektFilesResponses = {
    /**
     * Successful request
     */
    200: {
        data?: ItemsObjektFiles;
    };
};

export type UpdateSingleItemsObjektFilesResponse = UpdateSingleItemsObjektFilesResponses[keyof UpdateSingleItemsObjektFilesResponses];

export type ClientOptions = {
    baseUrl: 'https://jk100-admin.johannische-kirche.org' | (string & {});
};